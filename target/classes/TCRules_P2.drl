dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.domain.Job;
import bo.tc.tcplanner.domain.JobType;
import bo.tc.tcplanner.domain.Project;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import bo.tc.tcplanner.datastructure.converters.DataStructureBuilder;
import java.util.Map;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkMandatoryJobUnique"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,job.JobType == JobType.SCHEDULED, $job : job )
        $amount: Number() from accumulate(
            Allocation($job == job),count(1)
            )
        Number($amount > 1)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0, (-$amount.intValue()+1)*1000);
end

rule "checkDependencyId"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $index : index, $dependencyTimelineIdList : job.getDependencyTimelineIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(job != DataStructureBuilder.dummyJob, $timelineid : job.getTimelineid(), $timelineid == $dependencyId,index > $index)
    then
//        scoreHolder.addHardConstraintMatch(kcontext, 0, -100);
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(1000),$jobType == JobType.SCHEDULED ? -(1000) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $executionMode : executionMode,$predecessorsDoneDate : predecessorsDoneDate,$startDate : startDate,$predecessorsDoneDate > $startDate,$plannedDuration : plannedDuration)
        ExecutionMode(this==$executionMode, $name : job.name)

    then
//        scoreHolder.addHardConstraintMatch(kcontext, 0,-(int)(1000*($predecessorsDoneDate - $startDate)/($plannedDuration==0 ? 1 : $plannedDuration)));
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(int)(1000*($predecessorsDoneDate - $startDate)/($plannedDuration==0 ? 1 : $plannedDuration))
											,$jobType == JobType.SCHEDULED ?
											 -(int)(1000*($predecessorsDoneDate - $startDate)/($plannedDuration==0 ? 1 : $plannedDuration)): 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkDeadline"
   when
       $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $executionMode : executionMode,$job : executionMode.getJob(), $endDate : endDate)
       Job(this == $job,$deadline : deadline, $deadline < $endDate)
   then
//       scoreHolder.addHardConstraintMatch(kcontext, 0, $deadline - $endDate);
       		scoreHolder.addMultiConstraintMatch(kcontext,
       											new int[]{$deadline - $endDate,$jobType == JobType.SCHEDULED ? $deadline - $endDate : 0,0,0,0},
       											new int[]{0,0,0,0});
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,$job : job, $index : index, $previousStandstill : previousStandstill,$previousStandstill != DataStructureBuilder.dummyLocation,
            $jobType : jobType)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then

		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(100),$jobType == JobType.SCHEDULED ? -(100) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkRequirements"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange,
                                    $resourceChange_abs : resourceElementMap,
                                    $jobType : executionMode.job.jobType)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt, $req<0) from $resourceChange_delta.entrySet
        Map.Entry(key == $deltak, $net : value#ResourceElement.amt) from $resourceChange_abs.entrySet

        eval($net<0)
    then
			scoreHolder.addMultiConstraintMatch(kcontext,
												new int[]{(int)(100*$net),
															$jobType == JobType.SCHEDULED ? (int)(100*$net) : 0,0,0,0},
												new int[]{0,0,0,0});
end

rule "checkSplittable"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
        	$jobType : executionMode.job.jobType,
            $executionMode : executionMode,job.getSplittable() == 0,$progressdelta : progressdelta,$progressdelta<100 )
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{($progressdelta-100)*100,
														$jobType == JobType.SCHEDULED ? ($progressdelta-100) : 0,0,0,0},
											new int[]{0,0,0,0});
end



// ############################################################################
// Soft constraints
// ############################################################################

rule "distributeAllocations"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, prevJob != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "dummyJob"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end

rule "punishFragmentation"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $progressdelta : progressdelta,$progressdelta <100 )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
end

// ############################################################################
// Soft constraints
// ############################################################################

rule "distributeAllocations"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, prevJob != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "dummyJob"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end

rule "punishFragmentation"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $progressdelta : progressdelta,$progressdelta <100 )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
end

// ############################################################################
// Phase 2 Soft constraints
// ############################################################################
rule "checkExcessResource"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange,
                                    $resourceChange_abs : resourceElementMap,
                                    $jobType : executionMode.job.jobType)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt, $req<0) from $resourceChange_delta.entrySet
        Map.Entry(key == $deltak, $net : value#ResourceElement.amt) from $resourceChange_abs.entrySet
        eval($net> 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2,  (int)(-$net*100));
end

rule "laterTheBetter"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
            job.gravity == 1 || job.gravity == 0, $endDate : endDate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, (int)($endDate)*100);
end

rule "earlierTheBetter"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
            job.gravity == -1 , $endDate : endDate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, -(int)($endDate)*100);
end

rule "timePreference"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode, $startDate : startDate, $endDate : endDate, $requirementTimerange : executionMode.requirementTimerange)
        eval(!timeRestrictionCheck($allocation.getJob().getProject().getSchedule().getGlobalStartTime(),$startDate, $endDate, $requirementTimerange))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, -100);
end

