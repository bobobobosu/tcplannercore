dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import bo.tc.tcplanner.datastructure.converters.DataStructureBuilder;
import java.util.Map
import java.time.Duration
import java.time.ZonedDateTime;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkDependencyId"
    when
        $allocation : Allocation(isFocused(),
            $index : index, $dependencyTimelineIdList : executionMode.timelineProperty.dependencyIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(isFocused(), $timelineid : executionMode.timelineProperty.timelineid, $timelineid == $dependencyId,index > $index)
    then
        int score = -100;
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(isFocused(),
            $predecessorsDoneDate : predecessorsDoneDate,
            $startDate : startDate,
            $predecessorsDoneDate > $startDate)
    then
        int score = (int)(-100*((double)Duration.between($startDate, $predecessorsDoneDate).toMinutes()));
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end


rule "checkDeadline"
   when
       $allocation : Allocation(isFocused(),
            $executionMode : executionMode,
            $deadline : executionMode.chronoProperty.zonedDeadline,
            $endDate : endDate,
            $deadline < $endDate)

   then
        int score = (int)(-100*((double)Duration.between($deadline, $endDate).toMinutes()));
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(isFocused(),
            $executionMode : executionMode,
            $previousStandstill : previousStandstill)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then
        int score = -100;
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "checkRequirementsDeficit"
    when
        $allocation : Allocation(isFocused(),
                                    $score : resourceElementMapDeficitScore)
        eval($score<-0.001)
    then
        int score = (int)($score * 100);
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "checkCapacityRequirements"
    when
        $allocation : Allocation(isFocused(),
                                    $score : resourceElementMapExcessScore)
        eval($score<-0.001)
    then
        int score = (int)($score * 100);
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "checkSplittable"
    when
        $allocation : Allocation(isFocused(),
            executionMode.chronoProperty.splittable == 0,
            $progressdelta : progressdelta,
            $jobprogressdelta : executionMode.progressChange.progressDelta,
            eval($progressdelta != ($jobprogressdelta * 100) ))
    then
        int score = -(int)Math.abs($progressdelta-$jobprogressdelta * 100);
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

rule "timePreference"
    when
        $allocation : Allocation(isFocused(),
            $timerestrictionscore : timeRestrictionScore,
            $timerestrictionscore < -5)
    then
        int score = (int)($timerestrictionscore*100);
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{$allocation.isOld() ? score : 0, score, 0,0,0},
											new int[]{0,0,0,0});
end

// ############################################################################
// Soft constraints
// ############################################################################
//
rule "distributeAllocations"
    when
        $allocation : Allocation(isFocused(),
            nextFocusedAllocation != null,
            eval(nextFocusedAllocation.getIndex() - index < 2))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end
//
rule "checkExcessResource"
    when
        $allocation : Allocation(isFocused(),
            $score : resourceElementMapUtilizationScore)
        eval($score< 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1,  (int)($score*100));
end
//
rule "dummyJob"
    when
        $allocation : Allocation(isFocused())
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end
//
//rule "punishFragmentation"
//    when
//        $allocation : Allocation(isFocused(),
//            $progressdelta : progressdelta,$progressdelta <100 )
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
//end
//


// ############################################################################
// Phase 2 Soft constraints
// ############################################################################

//rule "laterTheBetter"
//    when
//        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
//            job.gravity == 1 || job.gravity == 0, $endDate : endDate)
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 3, (int)($endDate)*100);
//end
//
//rule "earlierTheBetter"
//    when
//        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
//            job.gravity == -1 , $endDate : endDate)
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 3, -(int)($endDate)*100);
//end
//
//rule "timePreference"
//    when
//        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
//            $executionMode : executionMode, $startDate : startDate, $endDate : endDate, $requirementTimerange : executionMode.requirementTimerange)
//        eval(!timeRestrictionCheck($allocation.getJob().getProject().getSchedule().getGlobalStartTime(),$startDate, $endDate, $requirementTimerange))
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 3, -100);
//end
