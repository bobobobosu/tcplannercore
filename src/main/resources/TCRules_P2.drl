dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import bo.tc.tcplanner.datastructure.converters.DataStructureBuilder;
import java.util.Map
import java.time.Duration
import java.time.ZonedDateTime;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkDependencyId"
    when
        $allocation : Allocation(isFocused(),$isOld : isOld(),
            $index : index, $dependencyTimelineIdList : executionMode.timelineProperty.dependencyIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(isFocused(), $timelineid : executionMode.timelineProperty.timelineid, $timelineid == $dependencyId,index > $index)
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(1000),$isOld ? -(1000) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(isFocused(),$isOld : isOld(),
            $predecessorsDoneDate : predecessorsDoneDate,$startDate : startDate,$predecessorsDoneDate > $startDate)
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(int)Duration.between($startDate, $predecessorsDoneDate).toMinutes()
											,$isOld ?
											-(int)Duration.between($startDate, $predecessorsDoneDate).toMinutes() : 0,0,0,0},
											new int[]{0,0,0,0});
end


rule "checkDeadline"
   when
       $allocation : Allocation(isFocused(),$isOld : isOld(),
            $executionMode : executionMode, $deadline : executionMode.chronoProperty.zonedDeadline, $endDate : endDate, $deadline < $endDate)

   then
       		scoreHolder.addMultiConstraintMatch(kcontext,
       											new int[]{-(int)Duration.between($deadline, $endDate).toMinutes(),
       											$isOld ? -(int)Duration.between($deadline, $endDate).toMinutes() : 0,0,0,0},
       											new int[]{0,0,0,0});
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(isFocused(),$isOld : isOld(),
            $executionMode : executionMode, $index : index, $previousStandstill : previousStandstill)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(100),$isOld ? -(100) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkRequirementsDeficit"
    when
        $allocation : Allocation(isFocused(),
                                    $score : resourceElementMapDeficitScore,
                                    $isOld : isOld())
        eval($score<-0.001)
    then
			scoreHolder.addMultiConstraintMatch(kcontext,
												new int[]{(int)(100*$score),
															$isOld ? (int)(100*$score) : 0,0,0,0},
												new int[]{0,0,0,0});
end

rule "checkCapacityRequirements"
    when
        $allocation : Allocation(isFocused(),
                                    $score : resourceElementMapExcessScore,
                                    $isOld : isOld())
        eval($score<-0.001)
    then
			scoreHolder.addMultiConstraintMatch(kcontext,
												new int[]{(int)(100*$score),
															$isOld ? (int)(100*$score) : 0,0,0,0},
												new int[]{0,0,0,0});
end

rule "checkSplittable"
    when
        $allocation : Allocation(isFocused(),
        	$isOld : isOld(),
            $executionMode : executionMode,
            executionMode.chronoProperty.splittable == 0,
            $progressdelta : progressdelta,
            $jobprogressdelta : executionMode.progressChange.progressDelta,
            eval($progressdelta != ($jobprogressdelta * 100) ))
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{(-(int)Math.abs($progressdelta-$jobprogressdelta * 100))*100,
														$isOld ? (-(int)Math.abs($progressdelta-$jobprogressdelta * 100)) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "timePreference"
    when
        $allocation : Allocation(isFocused(),
            $timerestrictionscore : timeRestrictionScore, $timerestrictionscore < -5)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 1, (int)($timerestrictionscore*100));
end

// ############################################################################
// Soft constraints
// ############################################################################

rule "distributeAllocations"
    when
        $allocation : Allocation(isFocused(), nextFocusedAllocation != null, eval(nextFocusedAllocation.getIndex() - index < 2))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "dummyJob"
    when
        $allocation : Allocation(!isFocused())
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end

//rule "punishFragmentation"
//    when
//        $allocation : Allocation(isFocused(),
//            $progressdelta : progressdelta,$progressdelta <100 )
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
//end

