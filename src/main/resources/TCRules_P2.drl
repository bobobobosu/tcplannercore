dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.domain.Job;
import bo.tc.tcplanner.domain.JobType;
import bo.tc.tcplanner.domain.Project;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import bo.tc.tcplanner.datastructure.converters.DataStructureBuilder;
import java.util.Map;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkMandatoryJobUnique"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,job.JobType == JobType.SCHEDULED, $job : job )
        $amount: Number() from accumulate(
            Allocation($job == job),count(1)
            )
        Number($amount > 1)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0, (-$amount.intValue()+1)*100);
end

rule "checkDependencyId"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $index : index, $dependencyTimelineIdList : job.getDependencyTimelineIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(job != DataStructureBuilder.dummyJob, $timelineid : job.getTimelineid(), $timelineid == $dependencyId,index > $index)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0, -100);
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,$predecessorsDoneDate : predecessorsDoneDate,$startDate : startDate,$predecessorsDoneDate > $startDate,$plannedDuration : plannedDuration)
        ExecutionMode(this==$executionMode, $name : job.name)

    then
        scoreHolder.addHardConstraintMatch(kcontext, 0,-(int)(1000*($predecessorsDoneDate - $startDate)/($plannedDuration==0 ? 1 : $plannedDuration)));
end

rule "checkDeadline"
   when
       $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,$job : executionMode.getJob(), $endDate : endDate)
       Job(this == $job,$deadline : deadline, $deadline < $endDate)
   then
       scoreHolder.addHardConstraintMatch(kcontext, 0, $deadline - $endDate);
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,$job : job, $index : index, $previousStandstill : previousStandstill,$previousStandstill != DataStructureBuilder.dummyLocation,
            $jobType : jobType)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then
        scoreHolder.addMultiConstraintMatch(kcontext,
                                            new int[]{0, ($jobType!=JobType.STANDARD)  ? -(100) : 0,
                                                        0,
                                                        -(100),0},
                                            new int[]{0,0,0,0});
end

rule "checkRequirements"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange,
                                    $jobType : executionMode.job.jobType,
                                    $valueEntryMap : project.schedule.valueEntryMap)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt) from $resourceChange_delta.entrySet
        Map.Entry(key == $deltak ,$capacity:value#ValueEntry.capacity) from $valueEntryMap.entrySet

        $net : Double() from accumulate(
            Allocation(job != DataStructureBuilder.dummyJob,index <= $index, $resourceChange_prev : executionMode.resourceStateChange.resourceChange, $progressdelta : progressdelta) and
            Map.Entry(key == $deltak,$amt : value#ResourceElement.amt) from $resourceChange_prev.entrySet,
                 init( double total = 0; ),
                 action( total += $amt*$progressdelta/100; ),
                 reverse( total -= $amt*$progressdelta/100; ),
                 result( total )
        )

        eval($net<0 || ($net>$capacity))
    then
            scoreHolder.addMultiConstraintMatch(kcontext,
                                                new int[]{($jobType!=JobType.STANDARD) ? ($net>$capacity ? (int)(100*($capacity-$net)) : (int)(100*$net)) : 0,
                                                            0,
                                                            ($net>$capacity ? (int)(100*($capacity-$net)) : (int)(100*$net)),0,0},
                                                new int[]{0,0,0,0});
end


rule "checkSplittable"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,job.getSplittable() == 0,$progressdelta : progressdelta,$progressdelta<100 )
    then
        scoreHolder.addHardConstraintMatch(kcontext, 4, $progressdelta-100);
end



// ############################################################################
// Soft constraints
// ############################################################################

rule "distributeAllocations"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob && job != DataStructureBuilder.sinkJob,prevJob != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "dummyJob"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end

rule "punishFragmentation"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $progressdelta : progressdelta,$progressdelta <100 )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
end



// ############################################################################
// Phase 2 Soft constraints
// ############################################################################
rule "checkExcessResource"
    when
        $allocation : Allocation($executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt) from $resourceChange_delta.entrySet

        $net : Double() from accumulate(
            Allocation(index < $index, $resourceChange_prev : executionMode.resourceStateChange.resourceChange, $progressdelta : progressdelta) and
            Map.Entry(key == $deltak,$amt : value#ResourceElement.amt) from $resourceChange_prev.entrySet,
                 init( double total = 0; ),
                 action( total += $amt*$progressdelta/100; ),
                 reverse( total -= $amt*$progressdelta/100; ),
                 result(  total  ))

        eval($net> 0)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2,  (int)(-$net*100));
end

rule "laterTheBetter"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
            job.gravity == 1 || job.gravity == 0, $endDate : endDate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, (int)($endDate)*100);
end

rule "earlierTheBetter"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, jobType != JobType.SINK, jobType != JobType.SOURCE,
            job.gravity == -1 , $endDate : endDate)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, -(int)($endDate)*100);
end

rule "timePreference"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode, $startDate : startDate, $endDate : endDate, $requirementTimerange : executionMode.requirementTimerange)
        eval(!timeRestrictionCheck($allocation.getJob().getProject().getSchedule().getGlobalStartTime(),$startDate, $endDate, $requirementTimerange))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 3, -100);
end

