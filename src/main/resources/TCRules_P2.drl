dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.domain.Job;
import bo.tc.tcplanner.domain.JobType;
import bo.tc.tcplanner.domain.Project;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import java.util.Map;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkMandatoryJobUnique"
    when
        $allocation : Allocation(job.name != "dummyJob",job.JobType == JobType.MANDATORY, $job : job )
        $amount: Number() from accumulate(
            Allocation($job == job),count(1)
            )
        Number($amount > 1)
    then
        // System.out.println("Rule Violation: "+ "checkMandatoryJob (" + $allocation.getJob().getTimelineid()+" "+ $allocation.getJob().getName()+")" );
        scoreHolder.addHardConstraintMatch(kcontext, 0, (-$amount.intValue()+1)*100);
end

rule "checkDependencyId"
    when
        $allocation : Allocation(job.name != "dummyJob",job.JobType == JobType.MANDATORY,
            $index : index, $dependencyTimelineIdList : job.getDependencyTimelineIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(job.name != "dummyJob", job.JobType == JobType.MANDATORY, $timelineid : job.getTimelineid(), $timelineid == $dependencyId,index > $index)
    then
        // System.out.println("Rule Violation: "+ "checkMandatoryJob (" + $allocation.getJob().getTimelineid()+" "+ $allocation.getJob().getName()+")" );
        scoreHolder.addHardConstraintMatch(kcontext, 0, -100);
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode,$predecessorsDoneDate : predecessorsDoneDate,$startDate : startDate,$predecessorsDoneDate > $startDate,$plannedDuration : plannedDuration)
        ExecutionMode(this==$executionMode, $name : job.name)

    then
        // System.out.println("Rule Violation: "+ "checkMandatoryJob (" + $allocation.getJob().getTimelineid()+" "+ $allocation.getJob().getName()+")" );
        scoreHolder.addHardConstraintMatch(kcontext, 0,-(int)(100*($predecessorsDoneDate - $startDate)/($plannedDuration==0 ? 1 : $plannedDuration)));
end

rule "checkDeadline"
   when
       $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode,$job : executionMode.getJob(), $endDate : endDate)
       Job(this == $job,$deadline : deadline, $deadline < $endDate)
   then
       scoreHolder.addHardConstraintMatch(kcontext, 0, $deadline - $endDate);
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode,$job : job, $index : index, $previousStandstill : previousStandstill,$previousStandstill != "Undefined",
            $jobType : jobType)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then
//        System.err.println($previousStandstill + " " + $currentLocation);
        scoreHolder.addMultiConstraintMatch(kcontext,
                                            new int[]{0, ($jobType==JobType.MANDATORY) ? -(100) : 0,
                                                        0,
                                                        -(100),0},
                                            new int[]{0,0,0,0});
end

rule "checkRequirements"
    when
        $allocation : Allocation(job.name != "dummyJob",$executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange,
                                    $jobType : executionMode.job.jobType,
                                    $valueEntryMap : project.schedule.valueEntryMap)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt) from $resourceChange_delta.entrySet
        Map.Entry(key == $deltak ,$capacity:value#ValueEntry.capacity) from $valueEntryMap.entrySet

        $net : Double() from accumulate(
            Allocation(job.name != "dummyJob",index <= $index, $resourceChange_prev : executionMode.resourceStateChange.resourceChange, $progressdelta : progressdelta) and
            Map.Entry(key == $deltak,$amt : value#ResourceElement.amt) from $resourceChange_prev.entrySet,
                 init( double total = 0; ),
                 action( total += $amt*$progressdelta/100; ),
                 reverse( total -= $amt*$progressdelta/100; ),
                 result( total )
        )

        eval($net<0 || ($net>$capacity))
    then
//            System.err.println($deltak + " " + $net + " "+ $capacity);
            scoreHolder.addMultiConstraintMatch(kcontext,
                                                new int[]{($jobType==JobType.MANDATORY) ? ($net>$capacity ? (int)(100*($capacity-$net)) : (int)(100*$net)) : 0,
                                                            0,
                                                            ($net>$capacity ? (int)(100*($capacity-$net)) : (int)(100*$net)),0,0},
                                                new int[]{0,0,0,0});
end

rule "checkSplittable"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode,job.getSplittable() == 0,$progressdelta : progressdelta,$progressdelta<100 )
    then
//         System.out.println("Rule Violation: "+ "checkMandatoryJob (" + $allocation.getJob().getTimelineid()+" "+ $allocation.getJob().getName()+ " "+ $currentLocation + " " +$previousStandstill +")" );

        scoreHolder.addHardConstraintMatch(kcontext, 4, $progressdelta-100);
end

rule "distributeAllocations"
    when
        $allocation : Allocation(job.name != "dummyJob",
            job.jobType==JobType.MANDATORY || job.jobType==JobType.STANDARD,index > 1,job.name != "dummyJob",prevJob.name != "dummyJob")
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0,  -(100));
end

// ############################################################################
// Soft constraints
// ############################################################################


rule "dummyJob"
    when
        $allocation : Allocation(job.name!= "dummyJob")
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "punishFragmentation"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $progressdelta : progressdelta,$progressdelta <100 )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
end



// ############################################################################
// Phase 2 Soft constraints
// ############################################################################
rule "checkExcessResource"
    when
        $allocation : Allocation($executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange)
//                                    job.jobType == JobType.SINK)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt) from $resourceChange_delta.entrySet

        $net : Double() from accumulate(
            Allocation(index < $index, $resourceChange_prev : executionMode.resourceStateChange.resourceChange, $progressdelta : progressdelta) and
            Map.Entry(key == $deltak,$amt : value#ResourceElement.amt) from $resourceChange_prev.entrySet,
                 init( double total = 0; ),
                 action( total += $amt*$progressdelta/100; ),
                 reverse( total -= $amt*$progressdelta/100; ),
                 result(  total  ))

        eval($net> 0)
    then
        // System.out.println("Rule Violation: "+ "checkMandatoryJob (" + $allocation.getJob().getTimelineid()+" "+ $allocation.getJob().getName()+")" );
        scoreHolder.addSoftConstraintMatch(kcontext, 0,  (int)(-$net*100));
end

rule "laterTheBetter"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode, $endDate : endDate)
        Job(this == $executionMode.job, name != "dummyJob",jobType != JobType.SINK,jobType != JobType.SOURCE,
               gravity == 1 || gravity == 0)

    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, (int)($endDate)*100);
end

rule "earlierTheBetter"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode, $endDate : endDate)
        Job(this == $executionMode.job, name != "dummyJob",jobType != JobType.SINK,jobType != JobType.SOURCE,
               gravity == -1)

    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -(int)($endDate)*100);
end


rule "timePreference"
    when
        $allocation : Allocation(job.name != "dummyJob",
            $executionMode : executionMode, $startDate : startDate, $endDate : endDate)
        ExecutionMode(this == $executionMode, $requirementTimerange : requirementTimerange)
        eval(!timeRestrictionCheck($allocation.getJob().getProject().getSchedule().getGlobalStartTime(),$startDate, $endDate, $requirementTimerange))
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 2, -100);
end

