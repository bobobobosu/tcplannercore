dialect "java"

import org.optaplanner.core.api.score.buildin.bendable.BendableScoreHolder;
import static bo.tc.tcplanner.app.Toolbox.*;
import static bo.tc.tcplanner.app.DroolsTools.*;
import bo.tc.tcplanner.domain.Allocation;
import bo.tc.tcplanner.domain.Schedule;
import bo.tc.tcplanner.domain.ExecutionMode;
import bo.tc.tcplanner.domain.Job;
import bo.tc.tcplanner.domain.JobType;
import bo.tc.tcplanner.domain.Project;
import bo.tc.tcplanner.datastructure.ResourceElement;
import bo.tc.tcplanner.datastructure.ValueEntryMap;
import bo.tc.tcplanner.datastructure.ValueEntry;
import bo.tc.tcplanner.datastructure.converters.DataStructureBuilder;
import java.util.Map
import java.time.Duration;

global BendableScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "checkMandatoryJobUnique"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,job.JobType == JobType.SCHEDULED, $job : job )
        $amount: Number() from accumulate(
            Allocation($job == job),count(1)
            )
        Number($amount > 1)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 0, (-$amount.intValue()+1)*1000);
end

rule "checkDependencyId"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $index : index, $dependencyTimelineIdList : job.getDependencyTimelineIdList )
        $dependencyId : Integer() from $dependencyTimelineIdList
        Allocation(job != DataStructureBuilder.dummyJob, $timelineid : job.getTimelineid(), $timelineid == $dependencyId,index > $index)
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(1000),$jobType == JobType.SCHEDULED ? -(1000) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkTimeOverlapping"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $executionMode : executionMode,$predecessorsDoneDate : predecessorsDoneDate,$startDate : startDate,$predecessorsDoneDate > $startDate,$plannedDuration : plannedDuration)
        ExecutionMode(this==$executionMode, $name : job.name)

    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(int)Duration.between($startDate, $predecessorsDoneDate).toMinutes()
											,$jobType == JobType.SCHEDULED ?
											-(int)Duration.between($startDate, $predecessorsDoneDate).toMinutes() : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkDeadline"
   when
       $allocation : Allocation(job != DataStructureBuilder.dummyJob,$jobType : jobType,
            $executionMode : executionMode,$job : executionMode.getJob(), $endDate : endDate)
       Job(this == $job,$deadline : deadline, $deadline < $endDate)
   then
       		scoreHolder.addMultiConstraintMatch(kcontext,
       											new int[]{-(int)Duration.between($deadline, $endDate).toMinutes(),
       											$jobType == JobType.SCHEDULED ? -(int)Duration.between($deadline, $endDate).toMinutes() : 0,0,0,0},
       											new int[]{0,0,0,0});
end

rule "checkPreviousStandstill"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $executionMode : executionMode,$job : job, $index : index, $previousStandstill : previousStandstill,$previousStandstill != DataStructureBuilder.dummyLocation,
            $jobType : jobType)
        ExecutionMode(this == $executionMode, $currentLocation : currentLocation, eval(!locationRestrictionCheck($previousStandstill,$currentLocation)))
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{-(100),$jobType == JobType.SCHEDULED ? -(100) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "checkRequirements"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,$executionMode : executionMode,
                                    $index : index,
                                    $resourceChange_delta : executionMode.resourceStateChange.resourceChange,
                                    $resourceChange_abs : resourceElementMap,
                                    $jobType : executionMode.job.jobType)
        Map.Entry($deltak:key, $deltav:value, $req : value#ResourceElement.amt) from $resourceChange_delta.entrySet
        Map.Entry(key == $deltak, $net : value#ResourceElement.amt) from $resourceChange_abs.entrySet

        eval($net<-0.001)
    then
			scoreHolder.addMultiConstraintMatch(kcontext,
												new int[]{(int)(100*$net),
															$jobType == JobType.SCHEDULED ? (int)(100*$net) : 0,0,0,0},
												new int[]{0,0,0,0});
end

rule "checkSplittable"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
        	$jobType : executionMode.job.jobType,
            $executionMode : executionMode,
            job.getSplittable() == 0,
            $progressdelta : progressdelta,
            $jobprogressdelta : executionMode.progressChange.progressDelta,
            eval($progressdelta != ($jobprogressdelta * 100) ))
    then
		scoreHolder.addMultiConstraintMatch(kcontext,
											new int[]{(-(int)Math.abs($progressdelta-$jobprogressdelta * 100))*100,
														$jobType == JobType.SCHEDULED ? (-(int)Math.abs($progressdelta-$jobprogressdelta * 100)) : 0,0,0,0},
											new int[]{0,0,0,0});
end

rule "timePreference"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
            $timerestrictionscore : timeRestrictionScore, $timerestrictionscore < -5)
    then
        scoreHolder.addHardConstraintMatch(kcontext, 1, (int)($timerestrictionscore*100));
end

// ############################################################################
// Soft constraints
// ############################################################################

rule "distributeAllocations"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob, prevJob != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 0, -100);
end

rule "dummyJob"
    when
        $allocation : Allocation(job != DataStructureBuilder.dummyJob)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, 1, -100);
end

//rule "punishFragmentation"
//    when
//        $allocation : Allocation(job != DataStructureBuilder.dummyJob,
//            $progressdelta : progressdelta,$progressdelta <100 )
//    then
//        scoreHolder.addSoftConstraintMatch(kcontext, 2,  $progressdelta < 50 ? -$progressdelta : $progressdelta-100);
//end
